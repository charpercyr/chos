mod redirection {
    use core::fmt;
    use chos_lib::bitfield::*;
    #[repr(transparent)]
    pub struct RedirectionEntryInner {
        pub bits: u64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for RedirectionEntryInner {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for RedirectionEntryInner {
        #[inline]
        fn clone(&self) -> RedirectionEntryInner {
            {
                let _: ::core::clone::AssertParamIsClone<u64>;
                *self
            }
        }
    }
    impl RedirectionEntryInner {
        pub const fn new(bits: u64) -> Self {
            Self { bits }
        }
        pub fn destination(&self) -> u8 {
            FieldCast::<u64>::from_repr(Bitfield::get_bits(&self.bits, 56usize, 63usize))
        }
        pub fn set_destination(&mut self, value: u8) {
            BitfieldMut::set_bits(
                &mut self.bits,
                56usize,
                63usize,
                FieldCast::<u64>::into_repr(value),
            )
        }
        pub fn mask(&self) -> bool {
            FieldCast::<u64>::from_repr(Bitfield::get_bits(&self.bits, 16usize, 16usize))
        }
        pub fn set_mask(&mut self, value: bool) {
            BitfieldMut::set_bits(
                &mut self.bits,
                16usize,
                16usize,
                FieldCast::<u64>::into_repr(value),
            )
        }
        pub fn trigger_mode(&self) -> TriggerMode {
            FieldCast::<u64>::from_repr(Bitfield::get_bits(&self.bits, 15usize, 15usize))
        }
        pub fn set_trigger_mode(&mut self, value: TriggerMode) {
            BitfieldMut::set_bits(
                &mut self.bits,
                15usize,
                15usize,
                FieldCast::<u64>::into_repr(value),
            )
        }
        pub fn remote_irr(&self) -> bool {
            FieldCast::<u64>::from_repr(Bitfield::get_bits(&self.bits, 14usize, 14usize))
        }
        pub fn pin_polarity(&self) -> PinPolarity {
            FieldCast::<u64>::from_repr(Bitfield::get_bits(&self.bits, 13usize, 13usize))
        }
        pub fn set_pin_polarity(&mut self, value: PinPolarity) {
            BitfieldMut::set_bits(
                &mut self.bits,
                13usize,
                13usize,
                FieldCast::<u64>::into_repr(value),
            )
        }
        pub fn delivery_status(&self) -> DeliveryStatus {
            FieldCast::<u64>::from_repr(Bitfield::get_bits(&self.bits, 12usize, 12usize))
        }
        pub fn destination_mode(&self) -> bool {
            FieldCast::<u64>::from_repr(Bitfield::get_bits(&self.bits, 11usize, 11usize))
        }
        pub fn set_destination_mode(&mut self, value: bool) {
            BitfieldMut::set_bits(
                &mut self.bits,
                11usize,
                11usize,
                FieldCast::<u64>::into_repr(value),
            )
        }
        pub fn delivery_mode(&self) -> DeliveryMode {
            FieldCast::<u64>::from_repr(Bitfield::get_bits(&self.bits, 8usize, 10usize))
        }
        pub fn set_delivery_mode(&mut self, value: DeliveryMode) {
            BitfieldMut::set_bits(
                &mut self.bits,
                8usize,
                10usize,
                FieldCast::<u64>::into_repr(value),
            )
        }
        pub fn vector(&self) -> u8 {
            FieldCast::<u64>::from_repr(Bitfield::get_bits(&self.bits, 0usize, 7usize))
        }
        pub fn set_vector(&mut self, value: u8) {
            BitfieldMut::set_bits(
                &mut self.bits,
                0usize,
                7usize,
                FieldCast::<u64>::into_repr(value),
            )
        }
    }
    impl core::fmt::Debug for RedirectionEntryInner {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.debug_struct("RedirectionEntryInner")
                .field("destination", &self.destination())
                .field("mask", &self.mask())
                .field("trigger_mode", &self.trigger_mode())
                .field("remote_irr", &self.remote_irr())
                .field("pin_polarity", &self.pin_polarity())
                .field("delivery_status", &self.delivery_status())
                .field("destination_mode", &self.destination_mode())
                .field("delivery_mode", &self.delivery_mode())
                .field("vector", &self.vector())
                .finish()
        }
    }
    impl core::cmp::PartialEq for RedirectionEntryInner {
        fn eq(&self, rhs: &Self) -> bool {
            true && self.destination() == rhs.destination()
                && self.mask() == rhs.mask()
                && self.trigger_mode() == rhs.trigger_mode()
                && self.remote_irr() == rhs.remote_irr()
                && self.pin_polarity() == rhs.pin_polarity()
                && self.delivery_status() == rhs.delivery_status()
                && self.destination_mode() == rhs.destination_mode()
                && self.delivery_mode() == rhs.delivery_mode()
                && self.vector() == rhs.vector()
        }
    }
    impl core::cmp::Eq for RedirectionEntryInner {}
    #[repr(transparent)]
    pub struct RedirectionEntry {
        inner: RedirectionEntryInner,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for RedirectionEntry {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for RedirectionEntry {
        #[inline]
        fn clone(&self) -> RedirectionEntry {
            {
                let _: ::core::clone::AssertParamIsClone<RedirectionEntryInner>;
                *self
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for RedirectionEntry {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for RedirectionEntry {
        #[inline]
        fn eq(&self, other: &RedirectionEntry) -> bool {
            match *other {
                RedirectionEntry {
                    inner: ref __self_1_0,
                } => match *self {
                    RedirectionEntry {
                        inner: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &RedirectionEntry) -> bool {
            match *other {
                RedirectionEntry {
                    inner: ref __self_1_0,
                } => match *self {
                    RedirectionEntry {
                        inner: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::core::marker::StructuralEq for RedirectionEntry {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for RedirectionEntry {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<RedirectionEntryInner>;
            }
        }
    }
    impl fmt::Debug for RedirectionEntry {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Debug::fmt(&self.inner, f)
        }
    }
    impl RedirectionEntry {
        pub const fn new(value: u64) -> Self {
            Self {
                inner: RedirectionEntryInner::new(value),
            }
        }
        pub fn bits(&self) -> u64 {
            self.inner.bits
        }
        pub fn set_defaults(&mut self) {
            self.set_vector(0);
            self.set_delivery_mode(DeliveryMode::Fixed);
            self.set_destination(Destination::Physical(0));
            self.set_pin_polarity(PinPolarity::HighActive);
            self.set_trigger_mode(TriggerMode::Edge);
            self.disable();
        }
        pub fn vector(&self) -> u8 {
            self.inner.vector()
        }
        pub fn set_vector(&mut self, v: u8) {
            self.inner.set_vector(v)
        }
        pub fn delivery_mode(&self) -> DeliveryMode {
            self.inner.delivery_mode()
        }
        pub fn set_delivery_mode(&mut self, d: DeliveryMode) {
            self.inner.set_delivery_mode(d)
        }
        pub fn destination(&self) -> Destination {
            let v = self.inner.destination();
            match self.inner.destination_mode() {
                false => Destination::Physical(v),
                true => Destination::Logical(v),
            }
        }
        pub fn set_destination(&mut self, d: Destination) {
            let mode: bool;
            let dest: u8;
            match d {
                Destination::Physical(v) => {
                    mode = false;
                    dest = v;
                }
                Destination::Logical(v) => {
                    mode = true;
                    dest = v;
                }
            }
            self.inner.set_destination_mode(mode);
            self.inner.set_destination(dest);
        }
        pub fn delivery_status(&self) -> DeliveryStatus {
            self.inner.delivery_status()
        }
        pub fn pin_polarity(&self) -> PinPolarity {
            self.inner.pin_polarity()
        }
        pub fn set_pin_polarity(&mut self, p: PinPolarity) {
            self.inner.set_pin_polarity(p);
        }
        pub fn trigger_mode(&self) -> TriggerMode {
            self.inner.trigger_mode()
        }
        pub fn set_trigger_mode(&mut self, m: TriggerMode) {
            self.inner.set_trigger_mode(m);
        }
        pub fn enabled(&self) -> bool {
            !self.inner.mask()
        }
        pub fn enable(&mut self) {
            self.set_enabled(true);
        }
        pub fn disable(&mut self) {
            self.set_enabled(false);
        }
        pub fn set_enabled(&mut self, e: bool) {
            self.inner.set_mask(e);
        }
    }
    pub enum Destination {
        Physical(u8),
        Logical(u8),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Destination {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Destination {
        #[inline]
        fn clone(&self) -> Destination {
            {
                let _: ::core::clone::AssertParamIsClone<u8>;
                let _: ::core::clone::AssertParamIsClone<u8>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Destination {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Destination::Physical(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "Physical");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Destination::Logical(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "Logical");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Destination {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Destination {
        #[inline]
        fn eq(&self, other: &Destination) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &Destination::Physical(ref __self_0),
                            &Destination::Physical(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &Destination::Logical(ref __self_0),
                            &Destination::Logical(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Destination) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &Destination::Physical(ref __self_0),
                            &Destination::Physical(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &Destination::Logical(ref __self_0),
                            &Destination::Logical(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for Destination {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Destination {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<u8>;
                let _: ::core::cmp::AssertParamIsEq<u8>;
            }
        }
    }
    #[repr(u64)]
    pub enum DeliveryMode {
        Fixed = 0,
        LowPriority = 1,
        SMI = 2,
        NMI = 4,
        Init = 5,
        ExInt = 6,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for DeliveryMode {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for DeliveryMode {
        #[inline]
        fn clone(&self) -> DeliveryMode {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for DeliveryMode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&DeliveryMode::Fixed,) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Fixed");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&DeliveryMode::LowPriority,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "LowPriority");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&DeliveryMode::SMI,) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "SMI");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&DeliveryMode::NMI,) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "NMI");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&DeliveryMode::Init,) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Init");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&DeliveryMode::ExInt,) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "ExInt");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for DeliveryMode {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for DeliveryMode {
        #[inline]
        fn eq(&self, other: &DeliveryMode) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for DeliveryMode {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for DeliveryMode {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    impl FieldCast<u64> for DeliveryMode {
        fn from_repr(v: u64) -> Self {
            match v {
                0 => Self::Fixed,
                1 => Self::LowPriority,
                2 => Self::SMI,
                4 => Self::NMI,
                5 => Self::Init,
                6 => Self::ExInt,
                _ => ::core::panicking::panic_str("Invalid repr for DeliveryMode"),
            }
        }
        fn into_repr(self) -> u64 {
            match self {
                Self::Fixed => 0,
                Self::LowPriority => 1,
                Self::SMI => 2,
                Self::NMI => 4,
                Self::Init => 5,
                Self::ExInt => 6,
            }
        }
    }
    #[repr(u64)]
    pub enum DeliveryStatus {
        Idle = 0,
        Pending = 1,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for DeliveryStatus {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for DeliveryStatus {
        #[inline]
        fn clone(&self) -> DeliveryStatus {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for DeliveryStatus {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&DeliveryStatus::Idle,) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Idle");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&DeliveryStatus::Pending,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "Pending");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for DeliveryStatus {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for DeliveryStatus {
        #[inline]
        fn eq(&self, other: &DeliveryStatus) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for DeliveryStatus {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for DeliveryStatus {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    impl FieldCast<u64> for DeliveryStatus {
        fn from_repr(v: u64) -> Self {
            match v {
                0 => Self::Idle,
                1 => Self::Pending,
                _ => ::core::panicking::panic_str("Invalid repr for DeliveryStatus"),
            }
        }
        fn into_repr(self) -> u64 {
            match self {
                Self::Idle => 0,
                Self::Pending => 1,
            }
        }
    }
    #[repr(u64)]
    pub enum PinPolarity {
        HighActive = 0,
        LowActive = 1,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for PinPolarity {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for PinPolarity {
        #[inline]
        fn clone(&self) -> PinPolarity {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for PinPolarity {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&PinPolarity::HighActive,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "HighActive");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&PinPolarity::LowActive,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "LowActive");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for PinPolarity {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for PinPolarity {
        #[inline]
        fn eq(&self, other: &PinPolarity) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for PinPolarity {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for PinPolarity {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    impl FieldCast<u64> for PinPolarity {
        fn from_repr(v: u64) -> Self {
            match v {
                0 => Self::HighActive,
                1 => Self::LowActive,
                _ => ::core::panicking::panic_str("Invalid repr for PinPolarity"),
            }
        }
        fn into_repr(self) -> u64 {
            match self {
                Self::HighActive => 0,
                Self::LowActive => 1,
            }
        }
    }
    #[repr(u64)]
    pub enum TriggerMode {
        Edge = 0,
        Level = 1,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for TriggerMode {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TriggerMode {
        #[inline]
        fn clone(&self) -> TriggerMode {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TriggerMode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&TriggerMode::Edge,) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Edge");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&TriggerMode::Level,) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Level");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TriggerMode {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TriggerMode {
        #[inline]
        fn eq(&self, other: &TriggerMode) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for TriggerMode {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for TriggerMode {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    impl FieldCast<u64> for TriggerMode {
        fn from_repr(v: u64) -> Self {
            match v {
                0 => Self::Edge,
                1 => Self::Level,
                _ => ::core::panicking::panic_str("Invalid repr for TriggerMode"),
            }
        }
        fn into_repr(self) -> u64 {
            match self {
                Self::Edge => 0,
                Self::Level => 1,
            }
        }
    }
}
